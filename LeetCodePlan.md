1. 初步准备
目标岗位分析：选择 1-3 个你想申请的职位，仔细阅读职位描述，确定每个岗位的核心要求和关键词（如 Java、Spring Boot、微服务等）。
收集已有材料：找出你现有的简历版本，列出之前的工作经历、项目、技能等内容，作为后续修改的基础。
2. 简历结构优化
确定简历格式：选择简历的格式，可以是反向时间顺序、按技能分类等，确保布局简洁、易读。
选择合适的模板：选择一个简洁且专业的简历模板。如果你还没有合适的模板，找一个你喜欢的在线简历工具或者 Word 模板。
3. 修改个人信息和职业目标
个人信息更新：确认联系方式（电话号码、邮箱、LinkedIn等）正确且易于联系。
职业目标定制：根据你选择的目标岗位，撰写一个简短的职业目标声明，展示你在 Java 和相关技术领域的经验和求职意向。
4. 工作经历部分
列出所有相关工作经验：将你所有的工作经历列出，并确保它们和目标岗位的要求相关。
突出技术技能：特别是对于 Java 开发的岗位，重点强调你在项目中使用 Java、Spring、微服务等技术的经验。
量化成果：尝试将每一段工作经历中的成就量化，例如“通过优化数据库查询，减少系统响应时间30%”。
针对岗位调整内容：根据不同岗位的需求，对每个工作经历进行微调，突出该岗位要求的技术或项目经验。
5. 项目经验部分
列出主要项目：选择与你目标岗位相关的 1-2 个项目，并详细描述它们。包括你在项目中的角色、使用的技术栈以及解决的问题。
展示技术细节：在每个项目中，展示你具体使用了哪些技术（如 Java、Spring、微服务、Docker等）以及你在项目中的贡献。
项目结果量化：如果可以，量化项目的成果，例如“提高系统性能20%”或“在4个月内成功交付”。
6. 技能部分
列出硬技能：根据目标岗位要求，列出你具备的技术技能。例如 Java、Spring、Hibernate、数据库管理、版本控制工具（如 Git）等。
匹配关键词：确保技能部分的关键字与目标岗位的描述一致，这有助于通过自动化简历筛选系统（ATS）。
添加软技能：如果岗位要求一些软技能（如团队合作、沟通能力等），可以简短地列出相关的能力。
7. 教育背景部分
更新教育信息：列出你的学历，包括学校名称、专业、毕业时间等。如果你的学位与技术岗位高度相关，可以适当补充一些在校期间的项目或课程。
课程和证书：如果你有与岗位相关的课程或认证，尤其是技术认证（如 Oracle Java Certification），可以列出。
8. 语言能力部分
展示英语水平：根据实际情况描述你的英语水平，尤其是在国际化的工作环境中使用英语的能力。可以用简洁的方式展示，如“Fluent in English: reading, writing, and speaking.”
9. 审核与优化
检查格式一致性：确保整个简历的字体、间距、段落格式等保持一致。
简洁性检查：删除不必要的细节和内容，保持简历在一到两页内，确保简洁且重点突出。
拼写和语法检查：使用拼写检查工具，确保没有拼写和语法错误。
10. 定制化简历
根据不同岗位微调简历：在简历初稿完成后，根据不同的公司和岗位要求，进行适当调整。例如，有的岗位可能需要你强调团队合作，而有的岗位需要你展示技术细节。
11. 最终审核和投递
请朋友或同行审阅：将简历交给朋友、同行或导师审阅，获取反馈并进一步优化。
准备投递：简历完成后，准备投递，确保所有信息准确无误。
保存多个版本：根据不同岗位需求，保存几份不同的简历版本，以便于快速投递。
12. 简历投递跟进
记录投递情况：保持记录，确保每次投递后跟进进展。可以使用表格或工具记录每次投递的公司、岗位和日期。
定期复盘：如果收到反馈，记下反馈中的问题，定期调整简历。

1. 基础知识巩固
掌握核心 Java 语法和概念：

复习 Java 的基本概念和特性，如面向对象编程（OOP）的四大原则（封装、继承、多态、抽象）、异常处理、Java 内存模型（堆和栈）、垃圾回收机制等。
资源推荐：
《Head First Java》：通俗易懂，适合打好基础。
《Effective Java》：进阶书籍，帮助你理解 Java 的最佳实践和细节。
深入理解集合框架：

学习常见的集合类（如 ArrayList, HashMap, LinkedList, HashSet）及其背后的数据结构原理。
理解如何选择合适的集合类来优化性能（如 HashMap 的时间复杂度、TreeMap 的排序能力）。
实践：自己实现常用的数据结构，比如链表、栈、队列、哈希表等。
多线程和并发编程：

了解线程的基本操作（如创建、启动、终止），掌握线程同步机制（如 synchronized, volatile）。
学习 Java 并发库（如 java.util.concurrent 包下的 ExecutorService, CountDownLatch, Semaphore 等），理解并发编程的设计模式（生产者-消费者模式、线程池等）。
资源推荐：
《Java Concurrency in Practice》：非常经典的并发编程书籍。
2. 加强后端开发技能
Spring 框架：

学习 Spring Core 的基础知识，如依赖注入（Dependency Injection）、控制反转（IoC）、面向切面编程（AOP）。
深入学习 Spring Boot，它简化了配置，并支持快速开发 RESTful API、微服务架构等。
项目实践：
创建一个使用 Spring Boot 的小项目，开发 RESTful API，使用 JPA 访问数据库。
了解 Spring Security 如何保护应用，学习如何进行认证和授权。
数据库管理：

强化 SQL 语法，理解数据库的基本操作，如增删改查（CRUD），以及索引、事务、锁机制的使用。
学习如何在项目中使用 Hibernate 或 Spring Data JPA 进行对象关系映射（ORM）。
NoSQL：熟悉 NoSQL 数据库（如 MongoDB、Redis）的基本概念，理解其应用场景。
3. 实践设计模式
常用设计模式：
学习常见的设计模式，如单例模式（Singleton）、工厂模式（Factory）、观察者模式（Observer）、策略模式（Strategy）、装饰者模式（Decorator）等。
理解每种模式的使用场景，能够灵活应用到实际开发中。
资源推荐：
《Head First 设计模式》：是非常好的入门书籍，内容通俗易懂。
4. 提升编程实践能力
算法与数据结构：

复习常见的数据结构（如数组、链表、树、图）和基本算法（如排序、搜索、动态规划等）。
每天坚持在 LeetCode、HackerRank 或 Codeforces 上做几道算法题，提高解决问题的能力。
理解算法的时间复杂度和空间复杂度，并尝试优化代码性能。
开源项目贡献：

通过参与开源项目，接触更多实际开发中常见的设计和架构问题。
可以从小型开源项目入手，修复 bug 或添加新功能。
自己动手做项目：

实际项目经验是提升编程能力的最佳方式。可以选择一个有挑战性的项目自己实现，比如一个个人博客系统、任务管理工具、简单的电商平台等。
这些项目不仅能帮助你练习 Java，还能结合数据库、Spring 框架、RESTful API、前后端交互等知识，构建完整的应用。
5. 理解 Java 生态系统和工具
版本控制：掌握 Git 的使用，了解如何在团队开发中管理代码、解决冲突。
构建工具：学习 Maven 或 Gradle 的使用，理解项目依赖管理和构建自动化。
容器化和部署：了解 Docker 的基本操作，学习如何将 Java 应用容器化，并使用 Kubernetes 进行简单的应用部署。
单元测试：掌握 JUnit 和 Mockito，了解如何编写高效的单元测试，并为项目提供良好的测试覆盖率。
6. 制定学习计划
短期目标（1-2个月）：

每天学习并实践 Java 基础知识，确保对集合、多线程等核心概念有扎实的理解。
完成一个小型的 Spring Boot 项目，熟悉 RESTful API 的开发流程。
中期目标（3-6个月）：

深入学习 Spring 生态系统和常用设计模式，应用到实际项目中。
掌握数据库和 ORM 工具，理解后端开发中数据库操作的最佳实践。
通过 LeetCode 和 HackerRank 等平台，系统性地练习数据结构和算法。
长期目标（6个月以上）：

参与开源项目，或自行开发完整的应用，积累实际项目经验。
学习分布式系统的设计，了解微服务架构、消息队列、负载均衡等高级技术。

1. 接受过去并重新定位
正视过去的经历：虽然你觉得在之前的公司没有积累太多东西，但工作中可能仍然有一些技能和经验是你可以借鉴的，比如项目管理、与团队的协作、问题解决能力等。这些软技能同样在未来的工作中很有用。
重新制定目标：对当前的状态有一个客观的认识，并为自己制定一个新的职业目标，不必急于求成。考虑你希望在未来的1-2年内在哪些方面有所进步，这可以是技术上的，也可以是软技能上的。
2. 不把年龄看作障碍
终身学习的心态：在技术领域，学习永远是持续的过程。年龄并不是学习或发展的障碍，尤其是在快速变化的技术行业，很多人也是在更晚的时候才开始深入掌握某些技术。
聚焦能力提升：比起担心年龄，重点关注你如何通过学习和实践来快速提升你的能力。通过系统的学习计划和实践积累，你的能力提升速度可能比你想象的要快得多。
3. 从小目标开始，逐步积累
设定小而具体的目标：例如，今天学习一个 Java 框架，明天实现一个小的项目模块。逐步积累知识和经验，不要急于求成。这样做可以避免你因目标过大而产生的挫败感。
记录进展：每天或每周记录你的学习和进展，这有助于你看到自己在成长，即使是一些微小的进步，也能给你带来成就感。
4. 重建信心
关注你的进步：对比过去，你在某些方面一定已经有所提升，即便是停下来休息的这一年半，也是你反思和调整自己的一部分过程。承认和接纳这些改变，重建信心。
接触同龄或年长的成功案例：你可能发现，很多人在年纪稍大时通过不断学习和积累，仍然能够在职业生涯中取得成功。这样的例子可以帮助你看到，年纪并不决定能力的上限。
5. 逐步恢复工作节奏
找到合适的步调：如果你觉得一开始工作压力过大，可以考虑先找一些轻松的项目或者兼职工作，逐步恢复自己的工作节奏。同时在这些过程中积累信心和能力。
加入技术社区或参与开源项目：参与开源项目或者技术社区不仅可以帮助你提升技术能力，还可以让你接触到更多业内人士，扩展人脉，并逐步重拾工作的动力。
6. 保持积极的心态
正念练习和自我关怀：通过正念练习或冥想来减少焦虑，关注当下的任务，不要过于担心未来或陷入对过去的懊悔。给自己一些时间，并学会自我关怀，不要给自己施加太多的压力。
心理咨询：如果你觉得长时间无法摆脱对职业发展的焦虑感，考虑寻求心理咨询或职业辅导，帮助你更加清晰地规划职业道路。
7. 具体技能提升
制定详细学习计划：你提到技术栈薄弱，先从基本的 Java 技术开始入手，每天学习一部分内容，然后逐渐扩展到更复杂的框架和工具。通过这个过程，逐渐提升你的能力。
实践项目：学习和实际项目相结合，不要只停留在理论层面，动手开发项目，哪怕是小型项目，也能大大提升你的自信和技术水平。
8. 避免过度比较
关注自己的路径：每个人的职业发展路径不同，不要过于与他人比较。你有自己的节奏和方向，重要的是你在为自己的职业目标做出努力。专注于自己的进步和积累，慢慢你会看到显著的提升。

《准备面试》
自我介绍准备
面试官通常会要求你简单介绍自己。你可以基于简历中的内容，简明扼要地突出你的技能和经验，特别是你在 Java开发 和 区块链项目 上的经验。
示例回答：
“I am Yujia Zhang, a Software Engineer with extensive experience in Java-based development and blockchain solutions. Over the past few years, I’ve worked on projects that involve the development of secure, scalable applications using Java and Spring Boot. I’ve also contributed to blockchain projects, particularly focusing on Ethereum smart contracts and cryptographic algorithms based on China’s standards. I’m passionate about delivering innovative solutions that improve system efficiency and performance.”

2. 项目经历讲解
你可以从简历中的项目入手，详细描述一个你最熟悉的项目，讲述项目的背景、你负责的部分、使用的技术、以及最终的成果。
示例问题：
Tell me about the blockchain project you worked on. What were your responsibilities?
Can you describe how you optimized the smart contracts and improved the performance?
回答结构：你可以采用 STAR 方法（Situation, Task, Action, Result）来回答。
"In my role at Zhiji Automotive, I worked on integrating cryptographic algorithms into Ethereum’s core for a secure blockchain solution. My main task was to implement SM2/SM3/SM4 algorithms to meet China's security standards. I optimized smart contract execution, reducing gas costs by 15% and improving scalability by 20%."

3. 技术性问题准备
重点准备 Java开发 和 区块链 相关的问题。Amazon 可能会问到技术细节，比如如何解决某个技术问题或优化系统性能。
常见 Java 面试问题：
What is the difference between HashMap and TreeMap?
Can you explain the Java memory model?
How do you handle multithreading in Java?
区块链和加密相关问题：
What are smart contracts, and how do you ensure their security?
What are consensus algorithms, and how do they work in blockchain?
How did you implement cryptographic algorithms into the Ethereum system?
4. 行为面试问题准备
Amazon 非常重视 Leadership Principles，你可能会被问到一些行为面试问题，探讨你如何在团队合作、问题解决等方面表现。
常见问题：
Tell me about a time when you had to handle a difficult challenge in a project.
Describe a situation where you disagreed with a team member. How did you resolve it?
示例回答：
"During a project, we encountered a security vulnerability in the blockchain system. I proposed a solution involving additional cryptographic checks, but a team member had concerns about its performance impact. We discussed both perspectives, tested our solutions, and eventually implemented a balanced approach that improved security without significantly affecting performance."

5. 系统设计问题准备
系统设计问题可能会考察你设计复杂软件系统的能力，特别是在大规模数据和高并发场景下。
示例问题：
How would you design a system for high availability and scalability?
Describe how you would architect a blockchain-based payment system.
你可以展示你在 Spring Boot 和 Java 中的经验，描述如何设计一个模块化、可扩展的系统。
6. Amazon Leadership Principles
熟悉 Amazon 的 领导力原则，这些原则会贯穿面试中的行为问题。你可以结合简历中的项目经历，展示你如何应用这些原则（如“Customer Obsession”或“Bias for Action”）。ba

10/29
##突出分布式系统和数据处理的经验##
**分布式数据查询、索引优化、或分片（sharding）方面的经验**
（可以在“Java-based Solutions Development”项目描述中强调分布式环境中的数据处理、性能优化的具体案例）

##增加对API和数据处理的具体经验##
1. 增加一些关于开发和优化API的具体细节，例如在您的Spring Boot和Spring MVC工作中如何处理数据流动和数据整合。
2. 考虑加入您在构建高效数据管道或管理数据库的项目实例，以展示您的数据工程能力。

##扩展对SDLC的详细描述##
明确您在SDLC的每个阶段的参与度，如代码评审、测试和部署过程。可以在“Work Experience”部分下增加一段话，说明您是如何参与完整的SDLC流程的。
**待做**

##增加您熟悉的其他编程语言和工具的描述##
尽管您在Java方面的经验很丰富，但因为该岗位偏好Python等数据科学工具，您可以在“Skills”部分加强Python和数据分析工具的描述，特别是如NumPy、Pandas等数据处理库。
如果您对SQL/NoSQL数据库有经验，也可以在“Database Management”部分更详细地说明，以突出数据处理能力。

##突出远程工作的经验##
如果有分布式团队工作或远程协作的经历，建议在“Cross-Cultural Communication”或“Work Experience”中强调远程工作和团队协作的能力，以展示适应远程工作的经验。

##调整格式和布局##
尝试将“Skills”部分中的条目进一步精简和分层，以提高可读性。例如，将每个技能分类（如“Programming Languages”、“Frameworks”、“Database Management”）列出，并将具体技能作为子项列在下方。
可以在关键成就或技能旁边添加量化数据，例如项目中提升了多少效率或降低了多少成本，以便突出您的具体贡献和成果。
**选择**

#整合过的工作笔记#
## 项目经验

### 以太坊2.0 分片与分布式系统优化
- **项目概述**：深入研究以太坊2.0中分片（Sharding）架构的实现与优化。分片技术用于提高区块链的扩展性，但在分片间的智能合约交互中存在数据同步与共享的复杂性。
- **技术细节**：
  - 设计了跨分片通信的机制，确保不同分片之间的信息同步与数据一致性。
  - 讨论了在分片网络中实现利益相关者管理、风险资金管理和随机数生成器等系统机制，确保分布式系统的安全性和效率。
- **成就**：通过分片机制的应用，提高了以太坊网络的交易吞吐量，增强了系统的扩展性和可靠性。

### 智能合约性能优化与测试
- **项目概述**：优化以太坊上的智能合约性能，专注于减少Gas消耗并提升执行效率。
- **技术细节**：
  - 优化了合约的循环逻辑和数据结构，在Ropsten测试网络上使用Ganache模拟高并发环境，测试优化后的合约性能。
  - 改进后，智能合约的Gas消耗降低了30%，执行时间减少了25%。
- **成就**：通过性能优化和测试，提高了智能合约的执行效率，降低了区块链应用的运营成本，为分布式系统的商业应用提供了技术支持。

### 网络通信与安全保障
- **项目概述**：在以太坊分布式系统环境中，优化了节点间的网络通信和数据传输安全性。
- **技术细节**：
  - 使用SSL/TLS加密机制，配置TCP/IP网络，确保多节点环境中的数据传输安全和可靠性。
  - 使用netstat和tcpdump进行网络流量分析，优化节点同步过程，增强系统的通信效率。
- **成就**：通过网络通信优化与安全配置，提高了分布式环境中的数据传输安全性，确保了多节点系统的稳定性。

### PoS共识机制与Casper FFG验证
- **项目概述**：研究并应用了以太坊信标链中的PoS共识机制，聚焦于验证器（validator）角色和投票流程的实现。
- **技术细节**：
  - 实施Casper FFG共识算法，管理验证者在不同epoch中的投票流程，并根据票数确定区块的最终性。
  - 研究了区块链的奖励和惩罚机制，确保验证者的行为符合网络安全和稳定性要求。
- **成就**：成功模拟并应用了PoS共识机制，提升了区块链网络的安全性和能源效率，为去中心化系统的长远发展提供了技术支持。

## 专业技能

- **分布式系统设计**：在以太坊分片架构中应用分布式系统设计原则，优化跨分片通信和分片间数据共享，提升系统扩展性。
- **智能合约优化**：精通以太坊智能合约的性能优化，具备在高并发环境下进行合约测试的经验。
- **网络安全与通信协议**：熟练掌握SSL/TLS加密机制、TCP/IP配置，并使用netstat和tcpdump进行多节点环境下的网络流量分析和优化。
- **共识机制实现**：对PoS共识算法和Casper FFG模型有深刻理解，能够实现区块链网络中的投票流程和验证机制，提升系统的安全性和效率。

10/30
Experienced Software Engineer with approximately three years of Java development experience and a robust background in blockchain and distributed systems. Skilled in designing and implementing scalable systems, with hands-on experience in database optimization, secure multi-node networking, and microservices architecture. Strong problem-solver with a track record of enhancing performance and efficiency in mission-critical environments. Fluent in English and Mandarin.

11/8
# PayPay Coding Test 两周准备计划

## 第一周：算法与数据结构强化

### Day 1: 数组与字符串
- 在 **LeetCode** 上练习数组与字符串相关的中等难度题目（10道）。
- 重点掌握数组的遍历、双指针、滑动窗口等技巧。

### Day 2: 链表与栈/队列
- 复习链表的操作（单链表、双向链表、环检测等）。
- 在 **LeetCode** 上练习链表和栈/队列相关的题目（8-10道）。
- 熟悉常见的链表题型，如反转链表、合并链表、栈的应用等。

### Day 3: 树与图的基础
- 复习二叉树的遍历（前序、中序、后序、层次遍历）以及 DFS 和 BFS。
- **LeetCode** 上练习树和图的基本题目（8道），例如二叉树的最大深度、最短路径问题等。

### Day 4: 排序与搜索算法
- 复习常见排序算法（快速排序、归并排序、堆排序）和二分查找。
- **LeetCode** 上练习排序与搜索相关题目（6-8道），重点是如何在应用场景中优化搜索效率。

### Day 5: 动态规划基础
- 学习动态规划的基本概念，包括背包问题和斐波那契数列。
- **LeetCode** 上练习经典动态规划题目（5道），例如爬楼梯、最大子数组和等。

### Day 6: 模拟面试 - 算法题目
- 用 1-2 小时进行模拟面试，涵盖本周的算法知识。可以用 Pramp 或其他平台找人模拟。
- 总结并记录自己的不足之处，为下周的系统设计和编程做准备。

### Day 7: 复习与总结
- 回顾本周的算法题目，总结解题思路和经验。
- 针对薄弱环节再刷几道相关题目。

---

## 第二周：系统设计与并发编程

### Day 8: 分布式系统设计概述
- 学习分布式系统的基本概念，包括负载均衡、缓存、CDN 和数据库分片。
- 阅读 **Grokking the System Design Interview** 中的基础部分，了解设计高并发系统的核心思路。

### Day 9: 微服务架构
- 了解微服务的基本概念、优缺点和设计模式，特别是服务间的通信（如 RESTful API、gRPC）。
- 设计一个简单的微服务架构（如社交媒体应用的消息服务），写出伪代码或架构图。

### Day 10: 并发与多线程
- 学习 Java 中的并发编程基础，如线程、线程池、同步锁、`java.util.concurrent` 包。
- 练习简单的并发编程题目，尝试用 Java 实现线程安全的代码。

### Day 11: 数据库设计与优化
- 学习关系型数据库和 NoSQL 数据库的设计，包括索引优化、事务管理、数据分区等。
- 了解如何设计一个高效的数据库结构，并用 SQL 实现基本的查询优化。

### Day 12: 系统设计案例：支付系统
- 设计一个高并发的支付系统，包括用户认证、订单管理和支付处理等模块。
- 确保设计包含安全性（如 SSL/TLS 加密）、缓存、消息队列和数据库分区等部分。
- 尝试在白板上绘制系统架构图，并解释各模块的设计理由。

### Day 13: 模拟面试 - 系统设计
- 进行一个系统设计的模拟面试，选择“支付系统”或“消息通知系统”作为题目。
- 回顾并优化自己的设计思路，确保能够清晰表达每个模块的作用和设计动机。

### Day 14: 综合复习与准备
- 回顾过去两周学习的所有内容，特别是系统设计和算法题目。
- 准备一些常见问题的答案（如微服务的优缺点、如何解决并发问题等），为面试中的问答环节做好准备。

---

## 额外建议
- **刷题平台**：在 LeetCode 上多练习 Java 算法题，以便熟悉语法和思路。
- **练习系统设计问答**：找一些常见的系统设计问题，并在心里演练回答。
- **模仿面试场景**：尽量用真实的面试环境进行模拟，帮助自己熟悉面试流程。

通过这个两周的计划，你可以在算法、系统设计和并发编程上有很大的提升，为 PayPay 的 coding test 做好充足准备。祝你顺利！

# LeetCode 常见解题思路分类

掌握一些常见的解题思路和分类可以帮助你在刷题时更加高效。以下是 LeetCode 中一些常见的解题思路分类。

## 1. 双指针 √

- **常见场景**：查找有序数组中的两数之和、判断链表是否有环、寻找最长无重复子串等。
- **经典方法**：左右指针（双向夹逼）、快慢指针（如链表检测）、滑动窗口（在字符串、数组中查找满足条件的子串或子数组）。
- **例题**：三数之和、最长子串无重复字符、环形链表检测。

## 2. 滑动窗口 √

- **常见场景**：在连续数据（如字符串、数组）中查找满足条件的子区间，特别是要求子区间和、频率或特定模式。
- **经典方法**：固定大小窗口或变动大小窗口（根据条件动态调整窗口边界）。
- **例题**：找到字符串中的所有异位词、最长子数组之和。

## 3. 哈希表/集合 √

- **常见场景**：频率统计、判断重复、快速查找等。
- **经典方法**：利用 `HashMap` 或 `HashSet` 提供的 O(1) 时间复杂度进行查找、插入和删除操作。
- **例题**：两数之和、判断数组中是否有重复元素、找到单独的数字。

## 4. 排序 + 贪心

- **常见场景**：寻找最大/最小值、区间问题（如活动选择问题）、任务调度。
- **经典方法**：先排序，再根据排序结果从头到尾扫描，决定每一步的局部最优解。
- **例题**：分发饼干、用最少箭引爆气球、跳跃游戏。

## 5. 动态规划 √

- **常见场景**：求最优解问题，如最短路径、最大子序列、组合数、背包问题等。
- **经典方法**：自底向上填表、记忆化搜索（自顶向下）、滚动数组优化空间。
- **例题**：爬楼梯、最长递增子序列、最大子序和、零钱兑换。

## 6. 深度优先搜索 (DFS) 与广度优先搜索 (BFS)

- **常见场景**：图、树的遍历和路径查找、连通分量、迷宫类问题。
- **经典方法**：递归实现 DFS，队列实现 BFS。回溯（Backtracking）也是一种 DFS 应用。
- **例题**：岛屿数量、二叉树的层序遍历、全排列、单词搜索。

## 7. 二分查找

- **常见场景**：在有序数组中查找元素，查找最优解或满足条件的区间。
- **经典方法**：二分法查找特定值，或通过自定义条件确定左/右边界。
- **例题**：搜索插入位置、寻找旋转排序数组中的最小值、求平方根。

## 8. 栈与队列

- **常见场景**：括号匹配、表达式求值、单调栈问题（如滑动窗口最大值、每日温度）。
- **经典方法**：利用栈的“后进先出”特性或队列的“先进先出”特性解决顺序相关问题。
- **例题**：有效的括号、柱状图中最大的矩形、每日温度。

## 9. 回溯

- **常见场景**：排列组合问题、迷宫路径、棋盘问题（如八皇后）。
- **经典方法**：逐步尝试所有可能的选择，遇到不符合条件的立即回退。
- **例题**：全排列、组合总和、N 皇后问题。

## 10. 树/图的常见操作

- **常见场景**：树的遍历（前序、中序、后序、层序）、最小生成树、最短路径等。
- **经典方法**：递归或迭代实现二叉树遍历，DFS 或 BFS 遍历图，Dijkstra、Floyd-Warshall 等算法求最短路径。
- **例题**：二叉树的最大深度、最低公共祖先、最小路径和。

---

掌握这些解题思路，可以帮助你快速识别题目类别，并选择合适的算法或数据结构。这些套路在 LeetCode 中不断练习，会帮助你逐步提升解题速度和准确性。

# 动态规划适用问题类型

动态规划（Dynamic Programming, DP）是一种非常强大的算法思想，通常用于解决以下几类问题：

## 1. 最优子结构问题

- **特点**：问题可以分解成多个子问题，且原问题的最优解可以由子问题的最优解推导得到。
- **例子**：最短路径问题、背包问题、股票买卖问题。
- **经典题目**：LeetCode 322 - 零钱兑换、LeetCode 1143 - 最长公共子序列。

## 2. 有重叠子问题的问题

- **特点**：相同的子问题在递归过程中被重复计算，动态规划通过记忆化存储已解决的子问题，避免重复计算。
- **例子**：斐波那契数列、爬楼梯问题、分割问题。
- **经典题目**：LeetCode 509 - 斐波那契数列、LeetCode 70 - 爬楼梯。

## 3. 计数问题

- **特点**：要求计算满足条件的方案数量，通常通过累加子问题的解来得到最终解。
- **例子**：路径计数、硬币组合、子集和问题。
- **经典题目**：LeetCode 62 - 不同路径、LeetCode 518 - 零钱兑换 II。

## 4. 序列问题

- **特点**：问题涉及序列中的元素，通常要求找到序列中的某种最优解，如最大值、最小值、最长子序列等。
- **例子**：最长递增子序列、最大子数组和、回文子序列问题。
- **经典题目**：LeetCode 300 - 最长递增子序列、LeetCode 53 - 最大子数组和、LeetCode 647 - 回文子串。

## 5. 划分问题

- **特点**：将问题划分为若干个不重叠的子问题，每个子问题可以通过动态规划求解。
- **例子**：最小分割数、数组分割、石子游戏。
- **经典题目**：LeetCode 410 - 分割数组的最大值、LeetCode 132 - 分割回文串 II。

## 6. 区间问题

- **特点**：问题涉及在一个区间内寻找最优解，通常使用二维数组表示区间并构建动态规划表格。
- **例子**：合并石子成本、最小加括号数、矩阵链乘法。
- **经典题目**：LeetCode 312 - 戳气球、LeetCode 1000 - 合并石头的最低成本。

## 7. 博弈问题

- **特点**：涉及两个玩家互相博弈的情况，通过动态规划计算在每一步中采取的最优策略。
- **例子**：两人石子游戏、堆积木游戏。
- **经典题目**：LeetCode 877 - 石子游戏、LeetCode 486 - 预测赢家。

---

## 总结

动态规划特别适合分阶段决策的最优解问题或满足条件的计数问题。通过将问题分解为子问题并存储中间解，DP 提供了高效的解决方案，避免了指数级的递归计算。

11/11
# 常见算法题解题模式

以下是一些在算法题中常见的模式，每种模式都可以应用于不同类型的题目。这些模式是解题思路的基础，熟悉它们会帮助你更快地识别问题类型并找到解法：

---

## 1. 双指针

- **用途**：适用于有序数组、链表等结构中的搜索、排序或两数和问题。
- **常见场景**：查找有序数组中的两数之和、判断链表是否有环、寻找最长无重复子串。
- **例题**：
  - **LeetCode 167** - Two Sum II
  - **LeetCode 283** - Move Zeroes

---

## 2. 滑动窗口

- **用途**：解决字符串或数组中关于子串或子数组的问题，通常用来找出满足条件的最优区间。
- **常见场景**：最长子串、最小子数组、异位词。
- **例题**：
  - **LeetCode 3** - Longest Substring Without Repeating Characters
  - **LeetCode 76** - Minimum Window Substring
  - **LeetCode 567** - Permutation in String

---

## 3. 哈希表

- **用途**：处理频率计数、快速查找、两数和等问题。
- **常见场景**：频率统计、重复元素检查、两数和。
- **例题**：
  - **LeetCode 1** - Two Sum
  - **LeetCode 242** - Valid Anagram
  - **LeetCode 771** - Jewels and Stones

---

## 4. 动态规划（DP）

- **用途**：最优化问题，比如最大值、最小值、计数问题等。通常用于解决具有重叠子问题和最优子结构的问题。
- **常见场景**：最短路径、子序列问题、组合问题。
- **例题**：
  - **LeetCode 53** - Maximum Subarray
  - **LeetCode 70** - Climbing Stairs
  - **LeetCode 300** - Longest Increasing Subsequence

---

## 5. 二分查找

- **用途**：用于有序数据结构的查找，或者在一组满足单调性的范围内查找特定值。
- **常见场景**：有序数组查找、寻找特定值或插入位置。
- **例题**：
  - **LeetCode 34** - Find First and Last Position of Element in Sorted Array
  - **LeetCode 69** - Sqrt(x)
  - **LeetCode 704** - Binary Search

---

## 6. 贪心算法

- **用途**：选择局部最优解，希望能达到全局最优。适用于可以证明局部选择能带来全局最优的情况。
- **常见场景**：区间问题、任务调度、最少硬币问题。
- **例题**：
  - **LeetCode 55** - Jump Game
  - **LeetCode 435** - Non-overlapping Intervals
  - **LeetCode 763** - Partition Labels

---

## 7. 深度优先搜索（DFS）和广度优先搜索（BFS）

- **用途**：图、树的遍历和路径查找，适用于连通性或路径问题。
- **常见场景**：图的连通性、树的路径、迷宫问题。
- **例题**：
  - **LeetCode 200** - Number of Islands (DFS/BFS)
  - **LeetCode 102** - Binary Tree Level Order Traversal (BFS)
  - **LeetCode 104** - Maximum Depth of Binary Tree (DFS)

---

## 8. 栈

- **用途**：用于处理后进先出（LIFO）结构的问题，比如括号匹配和逆序处理。
- **常见场景**：括号匹配、逆波兰表达式、栈模拟递归。
- **例题**：
  - **LeetCode 20** - Valid Parentheses
  - **LeetCode 155** - Min Stack
  - **LeetCode 739** - Daily Temperatures

---

## 9. 回溯

- **用途**：用于寻找所有可能的解，如组合、排列、子集等。通常通过递归尝试所有路径，并在失败时“回溯”。
- **常见场景**：排列组合、迷宫路径、棋盘问题。
- **例题**：
  - **LeetCode 39** - Combination Sum
  - **LeetCode 46** - Permutations
  - **LeetCode 78** - Subsets

---

## 10. 并查集

- **用途**：用于处理连通性问题，常见于图的连通分量和网络问题。
- **常见场景**：网络连通性、集合合并。
- **例题**：
  - **LeetCode 200** - Number of Islands
  - **LeetCode 547** - Friend Circles
  - **LeetCode 684** - Redundant Connection

---

## 11. 位运算

- **用途**：处理二进制相关问题，适用于需要进行位操作的题目，如子集问题、找唯一元素。
- **常见场景**：找单一元素、状态压缩。
- **例题**：
  - **LeetCode 136** - Single Number
  - **LeetCode 191** - Number of 1 Bits
  - **LeetCode 78** - Subsets (位运算实现)

---

## 12. 数学

- **用途**：数学推理和公式的应用，用于简化和优化问题。
- **常见场景**：找规律、排列组合、素数、最大公约数等。
- **例题**：
  - **LeetCode 204** - Count Primes
  - **LeetCode 7** - Reverse Integer
  - **LeetCode 172** - Factorial Trailing Zeroes

---

## 总结

掌握这些模式会帮助你更高效地识别和解决问题。每种模式都有其应用场景，练习这些模式的经典题目会让你在面临相似问题时更快找到思路。

# 典型算法题目

下面是一些典型的题目，涵盖了二分查找、贪心算法、动态规划、回溯和搜索（BFS和DFS）等类型，适合进一步练习巩固。

---

## 1. 二分查找 ✔

### [LeetCode 33 - Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
√
- **描述**：给定一个已旋转的 排序数组和一个目标值，找到目标值的位置。
- **难度**：中等
- **关键点**：二分查找如何在有序和部分有序的数组中应用。

### [LeetCode 69 - Sqrt(x)](https://leetcode.com/problems/sqrtx/)
√
- **描述**：给定一个非负整数 `x`，返回 `x` 的平方根的整数部分。
- **难度**：简单
- **关键点**：使用二分查找在一个数的范围内找到平方根。

### [LeetCode 162 - Find Peak Element](https://leetcode.com/problems/find-peak-element/)
√
- **描述**：找到一个数组中的峰值元素（大于相邻元素的值）。
- **难度**：中等
- **关键点**：利用二分查找的特点快速定位峰值。

---

## 2. 贪心算法

### [LeetCode 55 - Jump Game](https://leetcode.com/problems/jump-game/)
- **描述**：给定一个数组，每个元素表示最多可以跳多少步，判断是否能跳到最后。
- **难度**：中等
- **关键点**：贪心地记录最远跳跃的位置，判断是否可以到达终点。

### [LeetCode 435 - Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
- **描述**：给定一组区间，找到最小的区间删除数量，使剩余区间互不重叠。
- **难度**：中等
- **关键点**：按结束时间排序，每次选择不重叠的区间。

### [LeetCode 406 - Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/)
- **描述**：按高度和位置重建队列。
- **难度**：中等
- **关键点**：贪心算法先排序再插入的方法。

---

## 3. 动态规划

### [LeetCode 53 - Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)
- **描述**：找出具有最大和的连续子数组，并返回其和。
- **难度**：简单
- **关键点**：动态规划或贪心思想维护一个最大子数组和。

### [LeetCode 322 - Coin Change](https://leetcode.com/problems/coin-change/)
- **描述**：给定硬币种类和目标金额，求最少硬币数。
- **难度**：中等
- **关键点**：用动态规划求解最小硬币数，处理子问题的最优解。

### [LeetCode 300 - Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
- **描述**：给定一个无序的整数数组，找到最长上升子序列的长度。
- **难度**：中等
- **关键点**：动态规划求最长子序列，常用技巧包括二分查找优化。

---

## 4. 回溯

### [LeetCode 39 - Combination Sum](https://leetcode.com/problems/combination-sum/)
- **描述**：给定一组无重复的候选数和一个目标数，找到所有和为目标数的组合。
- **难度**：中等
- **关键点**：回溯法寻找所有可能的组合。

### [LeetCode 46 - Permutations](https://leetcode.com/problems/permutations/)
- **描述**：给定一个不重复的整数数组，返回其所有可能的排列。
- **难度**：中等
- **关键点**：通过回溯生成全排列。

### [LeetCode 79 - Word Search](https://leetcode.com/problems/word-search/)
- **描述**：在一个字母网格中找到是否存在某个单词的路径。
- **难度**：中等
- **关键点**：利用回溯和深度优先搜索（DFS）查找路径。

---

## 5. 广度优先搜索（BFS）和深度优先搜索（DFS）

### [LeetCode 200 - Number of Islands](https://leetcode.com/problems/number-of-islands/)
- **描述**：给定一个二维网格，1 表示陆地，0 表示水，计算岛屿的数量。
- **难度**：中等
- **关键点**：通过 DFS 或 BFS 遍历，寻找连通区域。

### [LeetCode 101 - Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
- **描述**：判断一个二叉树是否是对称的。
- **难度**：简单
- **关键点**：通过 DFS 或 BFS 比较左右子树是否相等。

### [LeetCode 133 - Clone Graph](https://leetcode.com/problems/clone-graph/)
- **描述**：克隆一个无向图，每个节点包含一个值和相邻节点的列表。
- **难度**：中等
- **关键点**：使用 DFS 或 BFS 深拷贝图，并处理节点的相互引用。

---

每个类型的题目都适合不同的解题思路和技巧。你可以根据兴趣和当前的掌握情况，依次进行练习和理解。希望这些题目能帮助你更好地巩固这些算法类型！

###11/14
- **学习阶段**：理解基本动态规划概念，通过经典的 LeetCode 70 - Climbing Stairs。√
- **提升阶段**：尝试 LeetCode 322 - Coin Change，通过背包问题感受动态规划在多层循环中的应用。√
- **挑战阶段**：尝试 LeetCode 472 - Concatenated Words，结合动态规划和回溯的综合题。√
- **检测阶段**：最后做 LeetCode 198 - House Robber，确保掌握状态转移的动态规划思路。